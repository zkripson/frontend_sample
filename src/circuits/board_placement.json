{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":6486223073495113955,"abi":{"parameters":[{"name":"ships","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"Ship","fields":[{"name":"start_x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_y","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"end_x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"end_y","type":{"kind":"integer","sign":"unsigned","width":8}}]}},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"board_commitment","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dB5jc1LW+M+ve7TUulEBC79Ko00toCQFsIECoGs0o1AABQ+i9926bUNMTEnqH9EYJLYE0UgyElpCeEMCYd84ixRqt8Isz/9G7ejv6PhhJnj17z7n/+U+5utqaevdYto/+N+zd8xr915d88jEqd69WcK9ecK+v4N6wgnvDC+6NKLg3suDeqIJ7owvujSm4N7bg3riCe+ML7k0ouDex4N6kgnuTC+5NKbjXn9wblrFx/kjnaLPk0+juMHGyYrdguBjZpmFkbTEt+Zyucgacnhgwe/QJGswyXNtue422aZmh0QiavmPYTtP1Td90fKfV8C2r7du+FzQDzwhM22qbsRNY7ZgPw5wGkBUnA5suNJF5wHU7zmm4uTDKdJSaqp6jzEg+Z6YGSR2Fb0g7Sk3hHGUGEIAzVTUcZYaqpqPUVfUcZdnkc7nUIKmj8A1pR6krnKMsCwTgcqoajrKsqqaj9KnqOcryyecKqUFSR+Eb0o7Sp3COsjwQgCuoajjK8ri5MCTnGZE5pDr3AWW9T2GJpp6Z4yXNu9HdYSLHnR3vipIDXlFA7kpAMEjpvVLGwCC5os6qgDatA2W9X1XTWZHjzo73A5ID/oCA3JWV3s7Keq+cMTBIbuFYu9V/pWSsdbANVhpC853aED03q4Cxg55jlrGKwpL8KkrGb9C618C69wnpvqSytQ7GK64RCiyBzc4kB2rfXAm8avK5mlKdJfCqavFyWXqPv5Qvi4dVZEK6LbFXBeq4GhgoEsnKqgofHFZXeicWqd5o4kUmA2uoahIt0p6wpnyJRLtm8rlWCtyUVNdUg4mWvyRNtFIT0i3RrgnUcS0lS7QIwmF90YSDtOHaSpa0je4OM7Vhn8DcoGQh52MdoO1U5kATPtJ+64J1lqgqgX4ywKfrKDzfrKewvixRoQKTxIECYA0BO66vuR1Vgh8kHtcWsKNRATwCE+4BPK4uYEdTycZoRK4p0W28ta53blIX0vu2ut7zzfF6PQG5t2s+36y3IaD3HWC902M4eJwNoC2Bvm0C/cUEYtC8Q3M8r0QyGgJ4tnBjNLJ9E5ab9k2kbFEXkIuyqy1kV3sJdkU0/NcVkHuX5r7VJ6T33ZrnBpwPrS8g9x7N55v1NgX0vlcoNxgG1h/ojyYQ42YWN93OxX1Cc4HubTrAeQXiz5SyXx1sv5WAslzgXLAMNG8xVlyF5y1PyeQqLFcqB0xtgc4BXaBdfSG7+hm7SuTAyNpRap5W0mzO310zjaMyN/oMg8kqb6NPkHxukBokBTXfkN7oMww20YYZKBxRbCA0kehAEeDmotQdccNV9Rxlw+Rzo9QgqaPwDWlHGa5wjrIhEIAbqWo4yoaqmo4yQlXPUTZOPjdJDZI6Ct+QdpQRCucoGwMBuImqhqNsrKrpKCNV9Rxl06zsrKPwDWlHGalwjrKpwgFwM1UNR9kUNxei2zYRmUOq80igrM0Vlmjqqpxtm8hxZ8e7heSAtxCQuyUQDFJ6b5kxMEiuqLMi6uHUpiOAsj6oqumsyHFnx7uV5IC3EpC7tdLbWVnvrTMGBskVWaXdMhkruoO65RCa79SG6LnZBowd9Bwz+W2jsCS/jZLxG7Tuw8G6jxTSvcytf7hGKLAELnHr37bJ53ZKdZbA26rBW//4S9Jb/6QmpNsSe1ugjtuBgSKRrGyr8MHhQ0rvxCLVG028yGTgw6qaRItbmgU25Usk2u2Tz4+kwE1JdXs1mGj5S9JEKzUh3RLt9kAdP6JkiRZBOKwvmnCQNtxByZK20d1hpjZEP4eIJG3kfOwItJ3KHGjCR9pvJ7DOElUl0E8G+HRHheebWQrryxIVKjBJHCgAPixgx9ma23FYgh8kHncQsOPOFcAjMOEewOOHBOy4i5KN0YhcU6Lb+FBd79xkhJDeD9f1nm+O17ME5D6i+Xyz3jsL6P0oWO/0QO+x3hVoS6Bvm0B/MYEYNB/VHM+8SrSrAJ4/ihtjxz4Qliu1vya1RV1ALsquuwnZdTclt8eaOWgnAbmPae5bI4X0flzz3IDzodkCcp/QfL5Z710E9H5SKDdA77EG+qMJxLiZxU23c/GU0Fyge5u7A+cViD9Tyn7o3iYyZu8BnAuWgeYtxsoeCs9bH1MyuQrLlcoBU1ugc8A9gHbdU8iueyq5PdZpbq37PCGfEETMebLHulXmRp9RMFnlbfTZK/ncOzVICmq+Ib3RZxRsog1zL4Ujir2FJhIdKPbCzUWpO+JGq+o5yj7J576pQVJH4RvSjjJa4RxlHyAA91XVcJR9VDUdZYyqnqPsl3yGqUFSR+Eb0o4yRuEcZT8gAENVDUfZT1XTUcaq6jlKM/mMUoOkjsI3pB1lrMI5ShMIwEhVw1GauLkQ3baJyBxSnccCZbUUlmjqqpxtm8hxZ8fblhxwW0BuDASDlN5xxsAguaLOiqiHU5uOAcr6uKqmsyLHnR3v/pID3l9A7gFKb2dlvQ/IGBgkV2SVNk7Giu6gxkNovlMboufmQDB20HPMBH+gwpL8gUrGb9C6jwbrPlZI9zK3/uEaocASuMStfwclnwcr1VkCH6QGb/3jL0lv/ZOakG5L7IOAOh4MBopEsnKQwgeHQ5TeiUWqN5p4kcnAJ1Q1iRa3NAtsypdItIcmn4elwE1J9VA1mGj5S9JEKzUh3RLtoUAdD1OyRIsgHNYXTThIGx6uZEnb6O4wUxuin0NEkjZyPj4JtJ3KHGjCR9rvCLDOElUl0E8G+PSTCs83RyqsL0tUqMAkcaAA+ISAHedobsdRCX6QeDxcwI5HVQCPwIR7AI+HCNjxaCUboxG5pkS3cUFd79xkjJDez9X1nm+O10cKyH1e8/lmvY8S0PsFsN7pgd5j/SmgLYG+bQL9xQRi0HxBczzzKtGnBPB8DG6MHftAWK7U/prUFnUBuSi7Hitk12OV3B5rzrGOEJD7oua+NVZI75c0zw04H5ojIPdlzeeb9T5aQO9XhHID9B5roD+aQIybWdx0OxevCs0Furd5HHBegfgzpeyH7m0iY/bxwLlgGWjeYqwcr/C8dYKSyVVYrlQOmNoCnQMeD7TriUJ2PVHJ7bFOc2vd5wn5hCBizpM91u0yN/qMg8kqb6PPScnnyalBUlDzDemNPuNgE22YJykcUZwsNJHoQHESbi5K3RE3XlXPUU5JPk9NDZI6Ct+QdpTxCucopwABeKqqhqOcoqrpKBNU9RzltOTz9NQgqaPwDWlHmaBwjnIaEICnq2o4ymmqmo4yUVXPUc5IPs9MDZI6Ct+QdpSJCucoZwABeKaqhqOcgZsL0W2biMwh1XkiUNZZCks0dVXOtk3kuLPjPVtywGcLyD0HCAYpvc/JGBgkV9RZEfVwatMJQFnnqmo6K3Lc2fGeJzng8wTknq/0dlbW+/yMgUFyRVZpz0nGiu6gnjOE5ju1IXpuLgBjBz3HTPAXKCzJX6Bk/Aat+3iw7hOFdC9z6x+uEQosgUvc+ndh8nmRUp0l8IVq8NY//pL01j+pCem2xL4QqONFYKBIJCsXKnxwuFjpnVikeqOJF5kMXKKqSbS4pVlgU75Eor00+bwsBW5KqpeqwUTLX5ImWqkJ6ZZoLwXqeJmSJVoE4bC+aMJB2vByJUvaRneHmdoQ/RwikrSR83EF0HYqc6AJH2m/K8E6S1SVQD8Z4NMrFJ5vrlJYX5aoUIFJ4kABcImAHedqbsdxCX6QeLxcwI7zKoBHYMI9gMeLBew4X8nGaESuKdFtfKOud24yQUjvN+t6zzfH66sE5L6l+Xyz3vME9F4I1js90HusrwbaEujbJtBfTCAGzYWa45lXia4WwPOncWPs2AfCcqX216S2qAvIRdn1GiG7XqPk9lhzjnWlgNxFmvvWRCG939E8N+B8aK6AXAarzvPNes8X0LvWJ5MboPdYA/3RBGLczOKm27moC80Furd5LXBegfgzpeyH7m0iY/Z1wLlgGWjeYqxcp/C8db2SyVVYrlQOmNoCnQNeB7TrDUJ2vUHJ7bFOc2vd5wn5hCBizv8v9lhPgskqb6PPjcnnZ1KDpKDmG9IbfSbBJtowb1Q4oviM0ESiA8WNuLkodUfcZFU9R/ls8vm51CCpo/ANaUeZrHCO8lkgAD+nquEon1XVdJQpqnqO8vnk8wupQVJH4RvSjjJF4Rzl80AAfkFVw1E+r6rpKP2qeo7yxeTzS6lBUkfhG9KO0q9wjvJFIAC/pKrhKF/EzYXotk1E5pDq3A+U9WWFJZq6KmfbJnLc2fF+RXLAXxGQexMQDFJ635QxMEiuqLMi6uHUplOAsr6qqumsyHFnx/s1yQF/TUDuzUpvZ2W9b84YGCRXZJX2pmSs6A7qTUNovlMboufmFjB20HPMBH+LwpL8LUrGb9C6Twbr3i+ke5lb/3CNUGAJXOLWv1uTz9uU6iyBb1WDt/7xl6S3/klNSLcl9q1AHW8DA0UiWblV4YPD7UrvxCLVG028yGTgDlVNosUtzQKb8iUS7Z3J510pcFNSvVMNJlr+kjTRSk1It0R7J1DHu5Qs0SIIh/VFEw7ShncrWdI2ujvM1Ibo5xCRpI2cj3uAtlOZA034SPvdC9ZZoqoE+skAn96j8Hxzn8L6skSFCkwSBwqAOwTseL/mdpyU4AeJx7sF7PhABfAITLgH8Hi7gB0fVLIxGpFrSnQbJ2u+r2aKkN5T+vSeb47X9wnI7dd8vlnvBwT0niq09wS9x/rrQFsCfdsE+osJxKA5VXM88yrR1wXw/A3cGDv2gbBcqf01qS0kVx27tes3hez6TSW3x5pzrHsF5E7T3Lf6hfSernluwPnQ/QJyZ2g+36z3gwJ6z6zIHmugP5pAjJszgHusl63IHutvAecViD9Tyn7o3iYyZn8bOBcsA81bjJVvKzxvfUfJ5CosVyoHTG2BzgG/DbTrd4Xs+l0lt8c6za11nyfkE4KIOU/2WMcqc6BjxfeAsu6tA9cy6tgHIeqqnEeiv6ew/pke35cc8PcF5P4ACCwpvX+QMTBIrmhi90OgrCeBzvpURZ31h0rGWR+SHPBDAnIfVno7K+v9cMbAILmi3fJHgLLuAjrrPThnNR8DynqioiTyiJIhkUclB/yogNwfKb1JhPX+UcbAILkiY+XM5GGFL8sfU1gnyz9fjG4rrpzIR8lbl2UA7bl1ojNK3k4kY5YCY7TE56AfTz6fUKrzmefH1eDnoPlL+eegR+QG1+3zxo8DJ+cJhQPibcDIeQdQ1kNAWY/UcSD7T8im2/ldGSyPyWY9IGa2TvwDJY/JZueMPVFzpQoOlOzs/D+ZfD6lVCexPKkGkw1/SZpsngSC5ymFm+hbgU59O1DWw0BZj9axAJbIjh9T+Izux7gxiuj9eMYfkXr/BKh3L7i8G1yGKWxwqXIm+3Ty+YxSnYHkaTU4uPCXpIPL00DwPKP0Dy7d6vgQUBYyk03xhMBGOr60XVBHOgR4EeenSu9Axf71U4G5+ZkqN1AZ3R0DLZf1gfLWTcaMsicHqtlAeRyohmfsCdG7xED18+TzF0p1BqWfq8GBir8kHah+DpycXwBl9RZRlkaSXDXwM4Un2V+qckkWUQ2sD5SXJ1mju2OgGtgFKI9JdmTGnkiM5g+U7Oz8P5t8/kqpTkJ9Vg0mWf6SNMk+CwTPrxRuou8CkhmSZB8HynpSc5LlAPxLhSfZX+PGKFIFsU/8WkDub4BzIzHf3AL8iYDev1XlBlWju8NcGSwv32LrLRZjg+qC5PM5pToD6AI1OKjyl6SD6gLg5DwHlHUrsHJBrt/oulic4gmBDekWG/LRy+eVbIA2ujsG/Ot5gbl5QZUbqIZC9TcbKK/qLbbfJZ8vKtUZlH6nBgcq/pJ0oPodEDwvKtxES1V/XT/2CJSle4uNF9tfUHiSfUmVS7JGd8dANWAC5a2b+DjKnr11jE6SfTn5fEWpTkJ9WQ0mWf6SNMm+DJycVxQOiHcDSfbe3jrGfyWVA/BLCk+yr+LGKFIFsU+8KiD398C5YRnoKi1tLaLkcUvxtwJ2/AMYP+mB3hz3GlBWrzuydEeZm+New8nq2Bz3R8kB/1FA7p+AgJfS+08ZA4Pkim6OQ2+vRz7thmzr/Vlhg6MEtv+s8MHsL5rjkJOClwX0/qvSOwnkefmrgNy/gXGOTgLT5Bclj5PePwjY8e9g/KDtmOIHJY9x83e1+EDqnh7oWPMPoKxXgAnwqxVNNP+Bk9WRaP5TcsD/FJD7OhBYUnq/njEwSK5otfovoCxdn0J+ESjr5YqSyL+UDIm8ITngNwTkvqn0JhHW+82MgUFyxarV1xU+y3tLYZ1sqL/K5QD17pISSt4RJONIBcZoietxC5PPt5XqXHtbqAavx72t5NfjFgIn522FA6Kur3JZAJT1fB0Hst5ue8NkshkDlMdkc1TGnqi5UgUHSnZ2/hcln+8o1Uksi9RgsuEvSZPNIiB43lG4idb1VS7PAWW9UMcCWCI7fkvhMzoWCBqjiN4LM/6I1LsG1LsXXN4NLqMUNrhUOZOtJ4DtywcS/of8Pf6SdHCp13Dg6avpH1y61XEBUBYyk1VKZp8JtwvQiy7Ixe1hmgcq9q9hNfzcDC85UBndHdq/yoUD1RygPA5UozP2hOhdYqAakQB2ZD4ojSgIVCNLCFQjgIFqJFBWbxFlaSTJVQPDBUh2VAWrAZ038zHJHg2UxyQ7NmNPJEbzB0p2dv5HJ4AdkyfU0QUkO6YEkh0NJMYxwGpA11e5vASU9YrmJMsBeJQAyY4VzuC7HR/7xFgBvccB/UNivllgTUDv8RWsXJDy0K9y6S0WdwbVCQlgJ+YD6ISCoDqxhKA6ARhUJwJl6bpZSdfFYqWq02JDPno5SfMWG/vXJIFANblX/cGrvzlAeVVvsU1JANufD0pTCgJVfwmBagowuPRXoPrr+nU1QFm6t9h4sX2yAMlOrWA1oPOrXHrrGJ0ku0wC2Gl5Ql2mgGSnlUCyywBJdhqQZHV9lctQWsfgADxVgGSna95iY5+YLqD3DHCLDV2lpa1FlDxuKY4XsONMMH7SA705btled2SpZD1fxyZfdVXO5rhlgXjMjne5muCAl6vh5S4PBLyU3stnLAySK7o5TudXuSDbeitovv7EuFlBIJi9T/N2JicFywjovaLmSSDPy4oCeq+keRKYJr8oeZz0zhSw4/vB+EHbMcUPSh7j5v1CsSs90LHmA8B8oNaHk1Xvq2ai+QGhRHPlmuCAVxZINFfRPNFkvVcRdlZ0tboq0Ka6PoW8CChLVZREVhUikdVqggNeTYBEVtecRFjv1StUra4ikOWtUcH1uDpQHvpVLueTjHFAeVeSjKsUGKMlrsetmQB2rfza25oF63FrlbAetyaQlNYClh+6vsrlDaCst+o4kPV22xsmk80EoDwmm3kZe6LmShUcKNnZ+V87IZt18sSydgHZrFMC2awNJJt1gGSj66tc3gTKWljHAlgiO15DIKNbV/N+NwfgtQX0Xq/kTHYoBJdxChtcqpzJrp8A1sgHkvULgotRQnBZHxhcjAoEl251fAMoC5nJKiWzz4TbBehFF+Titql5oGL/MgUCVaOCLRedX+XCgWouUB4HqvEZe0L0LjFQWQlg7XxQsgoClV1CoLKAgcruLaIslSzYIoopVw00BEjWqWA1oPNmPibZ+UB5TLITM/ZEYjR/oGRn599NAOvlCdUtIFmvBJJ1gcToAasBXV/l8g5QVk1zkuUA7AiQrC+cwXc7PvYJX0DvAOgfEvPNLcD1BPTeoIKVC9SuCvsql95icWdQ3TAB7Eb5ALphQVDdqISguiEwqG4ElKXrZiVdF4uVqk6LDfno5caat9jYvzYWCFSb9Ko/ePU3Fyiv6i22TRPAbpYPSpsWBKrNSghUmwJJY7MKVH/d6rgIKEv3Fhsvtm8iQLKbV7Aa0PlVLr11jE6S3SIB7JZ5Qt2igGS3LIFktwCS7JZAktX1VS5DaR2DA/DmAiT7Qc1bbOwTHxTQeytwiw1dpaWtRZQ8biluIGDHrcH4SQ/05rhtet2RpTlw3RGj3M1x2wDxmB3vtjXBAW9bw8vdDgh4Kb23y1gYJFd0c5zOr3JBtvU+pPn6E+PmQwLB7MOatzM5KdhCQO/tNU8CeV62F9D7I5ongWnyi5LHSe/WAnbcAYwftB1T/KDkMW52EIpd6YGONTsC48NM4Ktclq3oWxh2FEo0d6oJDngngURzluaJJus9S9hZ0dXqbKBNdX0KeRrO8c0ZFSWR2UIksnNNcMA7C5DILpqTCOu9S4Wq1VkCWd6uFVyPqwPloV/lcjPJmASUdy/JuE+BMVrietxHE8Dull97+2jBetxuJazHfRRISrsByw9dX+UyGRjR+4Hrcb3d9obJZDMFKI/J5oGMPVFzpQoOlOzs/O+ekM0eeWLZvYBs9iiBbHYHks0eQLLR9VUuU4BkM1XzxX/OPHcVyOg+pnm/mwPw7gJ671lyJjsUgsskhQ0uVc5k90oAu3c+kOxVEFz2LiG47AUMLntXILh0q+NkYIO7Xzi4IBahuV2AXnRBLm7vo3mgYv/aRyBQ7VvBlovOr3LhQHU/UB4HqskZe0L0LjFQ7ZcANswHpf0KAlVYQqDaDxiowt4iylLJmqF5FcTVwL4CJNusYDWg82Y+JtkHgfKYZPsz9kRiNH+gZGfnP0oA28oTalRAsq0SSDYCEmMLWA3o+iqX6UCSnak5yXIAbgqQbFs4g+92fOwTbQG9Y6B/SMw3twD3FND74xWsXJDy0K9y6S0WdwbV/RPAHpAPoPsXBNUDSgiq+wOD6gFAWbpuVtJ1sVip6rTYkI9eHqh5i43960CBQHVQr/qDV3/3A+VVvcV2cALYQ/JB6eCCQHVICYHqYCBpHFKB6q9bHacB14J0b7HxYvtBAiT7iQpWAzq/yqW3jtFJsocmgD0sT6iHFpDsYSWQ7KFAkj0MSLK6vsplKK1jcAD+hADJHq55i4194nABvT8JbrGhq7S0tYiSxy3FjwvY8QgwftIDvTnuyF53ZKlk9fdhk6+6Kmdz3JFAPGbHO6cmOOA5Nbzco4CAl9L7qIyFQXJFN8fp/CoXZFvvaM3Xnxg3RwsEs09p3s7kpOBQAb2P0TwJ5Hk5RkDvYzVPAtPkFyWPk94jBOx4HBg/aDum+EHJY9wcJxS70gOdAB8PjA+PARPgJ4AJ8ItAWS/jZJWaAB8vlACfUBMc8AkCCfCJmifArPeJFUmAHyYZryt84DipYi3+rdW7XV+UvJ1Ixs5Aex6g3u1So+QdQTKOVGCMltjiPzkB7Cn5dv7JBS3+U0po8Z8MJKVTgBnNw8DI+ShQ1gKgrOfrOJCV8dDG1olMlDwmm1kKZ08mmzFAeUw2R2XsiZorVXCgZGfn/9SEbE7LE8upBWRzWglkcyqQbE4Dks1DQKd+BCjrOaCsF+pYAEtkxycJtAJO17yFxgH4VAG9zyg5kx0KwWWUwgaXKmeyZyaAPSsfSM4sCC5nlRBczgQGl7MqEFy61XEBUBYyk1UKT4ZpuwDdx30YOMazNQ9U7F9nCwSqcyrYcpkNlMeBajjQnhyo5gDlcaAanbEnRO8SA9W5CWDPywelcwsC1XklBKpzgYHqvN4iylLJelk4UBndHQPVwDkCJHt+BauB2UB5eZI1ujsGqoGjgfKYZMdm7InEaP5Ayc7O/wUJYC/ME+oFBSR7YQkkewGQGC8EVgOPAckMSbIvAWW9ojnJcgA+X4BkL9L8qSX2iYsE9L4Y/NQSer65BXiGgN6XVLByGQaUl2+x9RaLsUH10gSwl+UD6KUFQfWyEoLqpcCgehlQ1kPAygW5fqPrYrFS1WmxvQ4c4+Wat9jYvy4XCFRX9Ko/ePU3Byiv6i22KxPAXpUPSlcWBKqrSghUVwKDy1UVqP661fFFoCzdW2y82H6FAMnOrWA1sAtQHpPsSKA9e+sYnSQ7LwHs/Dyhzisg2fklkOw8IMnOB5Ls40CSfbK3jvFfSeUAPFeAZK/WvMXGPnG1gN6fBrfY0FVa2lpEyeOW4iUCdrwGjJ/0QG+Ou7bXHVkqWc/XsclXXZWzOe5aIB6z472uJjjg62p4udcDAS+l9/UZC4Pkim6OQ78dAvm0G7Ktd4Pm60+MmxsEgtmNmrczOSmYJ6D3ZzRPAnlePiOg92c1TwLT5Bclj5PeawTs+DkwftB2TPGDkse4+ZxQ7EoPdAL8eWA+oOuDjYuAslRFX4/2eaEE+As1wQF/QSAB/qLmCTDr/cUKJcCrCASOL1Wwxa/z2yHOJxnjgPKuJBlXKTBGS2zxfzkB7Ffy7fwvF7T4v1JCi//LQFL6CjCj0fXtEG8AZb1Vx4Gst4HXMJlsJgDlMdnMy9gTNVeq4EDJzs7/TQnZfDVPLDcVkM1XSyCbm4Bk81Ug2ej6dog3gbIWar6eyJnnlwQyuq9p3kLjAHyTgN43l5zJDoXgMk5hg0uVM9lbEsDemg8ktxQEl1tLCC63AIPLrRUILt3q+AZQFjKTVUrm0XVuF6D7uMj1sts0D1TsX7cJBKrbK9hy0fntEByo5gLlcaAan7EnRO8SA9UdCWDvzAelOwoC1Z0lBKo7gIHqzt4iylLJUpr/zS2uBm4XINm7KlgN6Lw/iEl2PlAek+zEjD2RGM0fKNnZ+b87Aew9eUK9u4Bk7ymBZO8GEuM9wGpA17dDvAOUVdOcZDkA3yVAsvcKZ/Ddjo994l4Bve8DP7WEnm9uAd4soPf9FaxcdH47RG+xuDOoPpAA9sF8AH2gIKg+WEJQfQAYVB8EytJ1/4Oui8VKVafFtgoQJ1/XvMXG/vV1gUD1jV71B6/+5gLlVb3F9s0EsN/KB6VvFgSqb5UQqL4JJI1vVaD661bHRUBZurfYeLH9GwIk++0KVgM6vx2it47RSbLfSQD73TyhfqeAZL9bAsl+B0iy3wWSrK5vhxhK6xgcgL8tQLLf07zFxj7xPQG9vw9usaGrtLS1iJLHLcX7Bez4AzB+0gO9Oe6Hve7IUsl6q45NvuqqnM1xPwTiMTveh2qCA36oJrChCwh4Kb0fzlgYJFd0c5zOb4dAtvUe0Xz9iXHziEAwe1TzdiYnBd8R0PtHmieBPC8/EtD7Mc2TwDT5RcnjpPcHAnZ8HIwftB1T/KDkMW4eF4pd6YFOgJ8AxgddH2ychnujgzmjom+HeEIoAX6yJjjgJwUS4Kc0T4BZ76cqlADPEggcP65gi1/nt0PcTDImAeXdSzLuU2CMltji/0kC2Kfz7fyfFLT4ny6hxf8TICk9DcxodH07xGRgRO8Htvh7G3gNk8lmClAek80DGXui5koVHCjZ2fl/JiGbn+aJ5ZkCsvlpCWTzDJBsfgokG13fDjEFSDZTNV9P5MzzxwIZ3c80b6FxAH5GQO+fl5zJDoXgMklhg0uVM9lfJID9ZT6Q/KIguPyyhODyC2Bw+WUFgku3OmYz2W5l9QsHF8S6FrcL0H1c5HrZs5oHKvavZwUC1a8q2HLR+e0QHKjuB8rjQDU5Y0+I3iUGql8ngP1NPij9uiBQ/aaEQPVrYKD6TW8RZalkzdC8CuJq4FcCJPvbClYDOu8PYpJ9ECiPSbY/Y08kRvMHSnZ2/hckgH0uT6gLCkj2uRJIdgGQGJ9DrtQDiRFJstOBJDtTc5LlAPxbAZJ9XjiD73Z87BPPC+j9AvipJfR8cwvw5wJ6/66ClYvOb4foLRZ3BtUXE8C+lA+gLxYE1ZdKCKovAoPqS0BZuu5/0HWxWKnqtNhmAXHysuYtNvavlwUC1Su96g9e/d0PlFf1FturCWB/nw9KrxYEqt+XEKheBZLG7ytQ/XWr4zTgWpDuLTZebH9FgGT/UMFqQOe3Q/TWMTpJ9rUEsH/ME+prBST7xxJI9jUgyf4RSLK6vh1iKK1jcAD+gwDJ/knzFhv7xJ8E9P4zuMWGrtLS1iJKHrcUfydgx7+A8ZMe6M1xf+11R5ZKVn8fNvmqq3I2x/0ViMfseP9WExzw32p4uX8HAl5K779nLAySK7o5Tue3QyDbev/QfP2JcfMPgWD2T83bmZwUvCag9+uaJ4E8L68L6P0vzZPANPlFyeOk9y8CdnwDjB+0HVP8oOQxbt4Qil3pgU6A3wTGhxeBCfDLwARYy9dFGuUmwG8KJcBv1QQH/JZAArxQ8wSY9V5YkQT4dfXu69HQgePtirX4DyAZY4DyjiAZRwHt2ftzMJ0t/kUJYN/Jt/MXFbT43ymhxb8ISErvADOa54CR8wWgLF3/HEwZD20w2YwCymOyOVLh7MlkMwEoj8lmXsaeqLlSBQdKdnb+UzDU0lQvJRb+hzzZ8JekyUYB0/Qa0BEXAGU9D5T1JlDWwjoWwBLZ8dsCGV0dZ0MRvRfVFvsjUu8+oN694PJucBmnsMGlypnssORieD64DCsILsNLCC7DgMFleAWCS9c9UqAs3f+wYdouQPdxXweOcYTmgYr9a4RAoBpZcqAyujsGWi5zgPI4UI0G2rP3N7c6A9Wo5GJ0PlCNKghUo0sIVKOAxDsaKKu3iLI0kuSqgZECJDumgtXAHKC8PMka3R0D1cB8oDwm2YkZeyIxmj9QsrPzPza5GJcn2bEFJDuuBJIdCySzcUACehEoC0my7wBl1TQnWQ7AYwRIdrxwBt/t+NgnxgvoPQEZoAXmm1uAfQJ6T6xg5TIKKC/fYustFmOD6qTkYnI+qE4qCKqTSwiqk4BBdTJQ1gKgLOT6ja6LxUpVp8WG/CODUzRvsbF/TREIVP296g9e/c0Fyqt6i21qcrFMPlBNLQhUy5QQqKYCA8IyFaj+utVxEVCW7i02Zq5+AZKdVsFq4GigPCbZsUB79tYxOkl2enIxI0+y0wtIdkYJJDsdSBozgMT4ElDWK0BZQ2kdgwPwNAGSnal5i419YqaA3ssisaPwVVraWkTJ45biRAE7LgfGT3qgN8ct3+uOLJWst+rY5CuNsfkDzZPLA8edHe8KdcEBr1DHy30fsgIR0vt99cUGBskV3RyHfjsE8mk3ZFtvRXBwlMD2igLBbKW63jjkpGC6gN7v1zwJ5Hl5v4DeH9A8CUyTX5Q8TnqXE7DjymD8oO2Y4gclj3GzslDsSg90ArwKMB/Q9cFGLV8XaZSbAK8ilACvWhcc8KoCCfBqmifArPdqFUqAZwnsJVwdXGUO9bdD9P4cTGeLf43kYs2UfdN2/hr1wS1+/pJ0i38NICmtCYycur4dQtc/B9PbwPvun/SYApTHZPNAxp6ouVIFB0p2dv7XSi7WzpPNWgVks3YJZLMWkGzWBjq1rm+HmAIkm6marydy5rl6HZ/RraN5C40D8FoCeq9bciY7FILLJIUNLlXOZNdLLtbPB5f1CoLL+iUEl/WAwWX9CgSXrh/PB/69KN3/sGHaLkD3cZHrZYbmgYr9yxAIVGYFWy46vx2i9ze3OgNVI7mw8oGqURCorBICVQNI4hZQVm8RZWkkyVUDpgDJ2hWsBnTeH8Qk+yBQHpNsf8aeSIzmD5Ts7Pw7yYWbJ1mngGTdEkjWAZKZCyQzXd8OMR1IsjM1J1kOwLYAyXrCGXy342Of8AT09oE4lJhvbgGuK6B3UMHKRee3Q/QWizuD6gbJxYb5oLpBQVDdsISgugEwqG4IlKXr/gddF4uVqk6LDflHBjfSvMXG/rWRQKDauFf9wau/+4Hyqt5i2yS52DQfqDYpCFSblhCoNgEGhE0rUP11/WYD4FqQ7i02XmzfWIBkN6tgNaDz2yF66xidJLt5crFFnmQ3LyDZLUog2c2BBLQFkBh1fTvEUFrHGAjAAiS7peYtNvaJLQX0/iC4xYau0tLWIkoetxQDATtuBcZPeqA3x23d644slaz+PmzylcbY/IHmya2BeMyOd5u64IC3qePlbgsEqZTe29YXGxgkV3RznM5vh0C29bYDB0cJbG8nEMw+VNcbh5wUbC6g94c1TwJ5Xj4soPf2mieBafKLksdJ71YCdvwIGD9oO6b4Qclj3HxEKHalBzoB3gGYD2j57ltdGwJGuQnwDkIJ8I51wQHvKJAA76R5Asx671SRBJhfPSbxdohZdayTSbf4+QXLE4Dy+AXL84D27D3w09nin51c7Jyyb9rOn10f3OLnL0m3+GcDSWlnYEbzJlDWwv/vLa2S3g4h9bedUPbsvR2ik2x2SS52zZPNLgVks2sJZLMLkGx2BTq1pm8xHlJvh+DMc1Ydn9F9VPMWGgfgXQT03q3kTHYoBJfe2yEWH7snF3vkg8vuBcFljxKCy+7A4LJHBYJL7+0QS/emcolH15FvQP+Y5oGK/etjAoFqzwq2XCT+cCDKnr2nKjsD1V7Jxd75QLVXQaDau4RAtReQxPcGyuotoiyNJLlqYE8Bkt2ngtWAxB8ORM1T7+0QnSS7b3KxX55k9y0g2f1KINl9gWS2HzCD1/IPCA6xt0NwAN5HgGRD4Qy+2/GxT4QCejeRmBaYb24B7iagd1TBymUcUF6+xdZbLMYG1VZy0c4H1VZBUG2XEFRbwKDaBsp6AygLuX4zlN4OIdViQz5GHmveYmP/igUC1cd71R+8+uu9HWLxsX9ycUA+UO1fEKgOKCFQ7Q8MCAdUoPrrvR3iP5fKi+0fFyDZAytYDcwHymOSnQi0Z28do5NkD0ouDs6T7EEFJHtwCSR7EJBkDwYS4ztAWbXeOsZ/JZUD8IECJHuI5i029olDBPT+BDJxUPgqLW0touRxSzESsOOhYPykB3pz3GG97shSyarq2yEOA+IxO97D64IDPryOl/tJIEil9P5kfbGBQXJFN8eh3w6BfNoN2dY7AhwcJbB9hEAwO7KuNw45KThIQO85mieBPC9zBPQ+SvMkME1+UfI46T1UwI5Hg/GDtmOKH5Q8xs3RArEr7UiVkSghx53tqnwquTimnlOgT1CBbgH8qf88WYr+F1nmMfVqAqKmZABxbHJxnDQgakBAHAsExHEVBURdyQDi+OTiBGlA1IGAOB4IiBMqCog+JQOIE5OLk6QB0QcExIlAQJxUUUAMUzKAODm5OEUaEMOAgDgZCIhTKgqI4UoGEKcmF6dJA2I4EBCnAgFxWkUBMULJAOL05OIMaUCMAALidCAgzqgoIEYqGUCcmVycJQ2IkUBAnAkExFkVBQTwryt2AOLs5OIcaUCMAgLibCAgzqkoIIB/dawDEOcmF+dJA2I0EBDnAgFxXkUBMUbJAOL85OICaUCMAQLifCAgLqgoIMYqGUBcmFxcJA0I5N/8uhAIiIsqCgjgHrwOQFycXFwiDQjke7ouBgLikooCArg3pQMQlyYXl0kDAvn+mkuBgLisooAAvtK5AxCXJxdXSANiAhAQlwMBcUVFATFRyQDiyuTiKmlAIHeGXAkExFUVBQTwVZQdgJibXMyTBgRyo/9cICDmVRQQk5UMIOYnF1dLAyKrQLeAmA8ExNUVBQTwTegdgPh0cnGNNCCmAAHxaSAgrqkoIPqVDCCuTS6ukwZEPxAQ1wIBcV1FATFVyQDi+uTiBmlATAUC4nogIG4AAoInnddstsjY8d+yfavtBabZ8i3HCDy3EdAIXM+xzDgynSiMW14Q+kGz3Y6aVhAYVuwGjteIXMuN7dAJF+XkmaEXO+04DFtebJGAhhMGph9bRhT5Lc+yrDiKwqZH/xwFRmzarbZvNqPIafhxEFhOaxF2fo1BgHfsMPTd0LOiph9attNw2k6z2W65bdtqhqYZ+G3fNWIntgLHaLh+7Jmt2HYCs9lq20YjP76GEbSiuBk36H+OFwexa9hkGbvlmWHkxmHsew36lXHk2YYXGXa76TbM0G34XhRGZsOV1teMbDtuhE6DfrtvEuxC36IBOITCqO03CZ2m0bDZAHTqm0Gz2QpjJ2yErdC3PdsfND4rDNtty227dqMRmi3DDEzXapCuThCE7aDdJFBEjcj0Qj8KGkYYWgQiv+kHkRPTL5fWt+G2SCvTNSLXJz0Jd64Tu1HT9swGTUPbIBsEsW1ZPk+SHZqNKCBIxo1G3HTj5qD5NZzIMyKrGURGi7BsR6ZhtK2w4TVjK4osj5WK/ajVCmxCTmQbPrlLw2p5tmuT4rG4vka7FUQuzUTDa3g824HfjKO24Xh+ywlaTTNsNdsEec+yYy8Oo4i8vEmkE9hxFLvtQXgOopbXsoiSLL9pOX7kNiI7NIzYs0KjZRphM/TaThiGhu0Z9A+eacV+YLab7WbQsDxT3H8bNI1+2IzciEDVcgzLs1pk6haBMWyajssT4zWaVtOMvabvmsRDhtlwPMNptCzfGqQv6Uik1wyMdkjTHwQt13WMkNyCaJFouWk0TKfdNEIvMHzTaBK+COB+w/XozDPl9Y1Nw43dlu02iTCJcRsBUVjDDmgoccPyPUIgIdGm2NKIiawMO7JdUsGJbdcgNx48v2HTJ+B7jdhsERvbDfKJILLJVrHnmQYZi7y25ZoOMSMZzvUss237Lv2iJnmJJz+/gR832kQuNkUixwwin6e7FfDUEsoMk4jaN+IGUZUfmYFNM+yGTuCQM1puMJhPLadJbknhl7jIbkdt8twW4TcOKaRZrZjic2CQt1pkA5NcN3KIvtpNosswjHyrKe6/UUDBwPYCii7Ev+3Q89pekxICYpfYJq8OPZvmommSl/sNcuRGw4gapu/5ZuzGg8fX8PzYd2kyWwHNoNF0WmHDIlWJ8tuWY7cipxU1DeJD8pqmRzTe8FutZhw3TYNcxROPR0azzREjtkgZy6HAETpW6Llu3PZs4qrAtzyfiDMkhySkh2SPZuyaBH7ilrhpD/a3mLBuO4bhtP3ApYSCcBM4rkVRL4yDsNVqUU7T9ByiL0q2mg5Zx3BCi1DDwalhiM9vEMe+bXlhm3HoB4Fv2rbZbFiG5dJcNr24Rf9AcTOOjbZvUZShaxooZRPNlmsM4mczbjVsz3LoJ702eafbbDRaJC6Kvahl+/RvduxQMmmRkzRJUYI18YIVUCR0yfTy+hImW3abnNiPfJviR8vx6fDYmykxdPxGaFuO63hELBQwDb/tGO3ApohE3me3gsH6OhaRndsyKYY1bYo+dtgK2hR0nJD/3whIKLkNJaqmQ2in0O8bZjOg/NRoGI68/xIBBwapazcc8ifb9ij5cSgW+6SiT9kSpYFOq215zSbFYOIW+gIljKQVEXFgDcZzGNpem7Krltlo+Y5LaSUlyMxvxHNGxGm4y1VC3Arb/Nso2Ywpq25blHmaraY8P3NR4LdciqxuTMm7GwUmTaLVahoEPJ9mlHJ9v+0aLYv4mqah6VHsMuJ2ELpO240G8VUUU31gUBbdCgOb8siAshYqMyigt4gB7BYlLlQaWJyqBrbpGS0/aFBB5bXoF1HUEte3ZXq+RT7ZoPhDVGNSYRCRF/styvVNToZcqhUoS7AJ7wFzVEQ5SUxeTRztmfYgfdtN4l47jm0CSBxZVA2Qx0RWRJxtGI2mSYo1iOsbVCpQaOcoFxuUrbVD16fyI5LW16JUj2oam9jZC5vklBREyPycTBHDuITiKLDaNoVdilTEuB7VPL5LdEOAZf8e5L+m1wjdpuvZkUs/TemaaQQx2aAVWC0iemJjqj549g2faco1faohKHl1TDpc8XrQtGh0lk8lmUuVjR9SpGhRnuiGFlW9NmHXodTHDomyYqfBuT7VFC2feIjSMo9oZ9D8EhAcm35RHAZUObQJvhRbba53DSqWyPXdFheXVFqa5LcUhF0r8uj3clpp2fL1UdPyKAloN+2I2DNqUilKBb/vtCOq/wzHahOtUB4SUleALNBoe1T/E62Rx1nkf9Fg/+Wy0qMfpjBLxaUVBlQ9UnIetls8iV5IRTVVm0ZoRGbTM0LTi4kFXWoBtKlc8CL5ejBsm1FkO1YrbFpcptuUxlOyGHPCy4UBFQV0EO3GFmV+PhXolGk16TKk3GkQPzeoumpyDmFzQ8AiiqMSi0DUphLIsIMopmqYnLsdBi5lW65JcSEMnGbUaBvk2035/ka7QQkl2ZeivUeZBtGJ32wQN8WkWWw0qJ9jmG1K+kyqAci9XapzKKWmjKJNvGM2BvsvTahDMKUUkb2fJtsjMiKnp/aOETkuRR2fghnnrMRqTUomKUujSsql0skvIZ90nIhch+BKCbHVbnO+ZzRDKlqpdKUYRAm0QcWMTXCncqftuVS/U4JCXQHKFwv6G9SXo2rW5zqQGjbc8SG1CMFtxyHKozYC1SbkJE7LoVYApSbUGaCAHVFHy6dK3AjE8dyiZkpgG5RJUclqU/lCeSD5LdEMeW5AfQDPsalHR/NJTS7KAakYJB6zicEblHi0BsejqEXBzHSIyil0WU3fp14XobVFiZTLlgsp46BaiKpnyrmofIoo5rVpgqn4MgbX00aXB+u7TiKLz3mf+qLk/JjM+bGZ8+My58dnzk/InJ+YOT8pc35y5vyUzPmpmfPTMuenZ87PyJyfmTk/K3N+dub8nMz5uZnz8zLn52fOL8icX5g5vyhzfnHm/JLM+aWZ88sy55dnzq/InF+ZOb8qcz43cz4vcz4/c3515vzTmfNrMufXZs6vy5xfnzm/ITnH4cl00PhkeTfSOD9D/322rjqOeu53dbuesAxu3OaN4PWEdJFpmYz+tcQGfcm/89ZC3k3GG4h4/YG3CfCT4fwwMD//yY/88VNe/GAPP8vBy/e8YsuLdFPV4sWq7O+YmjnfJvnc8u1nt7nl0jPXyPyT2i792Rc2n3n4w1/YKvtvs5fwc7ss4efOWcLPnbeEn7t8CT935RJ+7pEl/NyPlvBzzyzh5362hJ8bX3vvn5tYe++fm7GEn1t2CT+34xJ+btYSfu5jS/i5vd7j59J1w1WSz9HJZ+qzteQ7myXXRneHOTojFy3fp977aNV5gMdvjVaL/VnKPqlMAfnGyETOB09eLD+vCx/j1eI3H6vczzBnTVCLzydlfoaPrTKya7l/27rg90rqTJhwUvnDBOTT0egvGP+wjG58bHmy+vfxX/5eM39jbGL/9yXy+grGUcuNqU+995yrgnu1Ajn13Hdr7/H7s3r3qcFz8F5jK7KjKrhXNLa+/2VswwrGlpdbX4Ie7/V7smNK7TNeDbZ1LfdvRWPneU1xM+zkzn/fLLlvdHFQ+fPv+qkvkT9cDcZB9vcPz31/5eR6TGb8WVts9l+OM/ZCqldpGcqhNQrqg03JyVcZe6b4Vxl7ZceD9PHRmd8pIP/fvJw9xmTOx+b+LbXBsIKfq73HdT33uaTv5u9n740v+LdUZvqXNrPjTfUYnftcJiNXIseYKiO/cK6KcvF8LqWAY0jlpT47XA0+6rl/S7+b95kafnxmfix9Bb8rPVLMZGuY1J7/AzvLj/kuLQQA","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"61":{"source":"// SPDX-License-Identifier: MIT\n// Battleship Board Placement Circuit with Improved Hashing\n\n// Import the standard library\nuse std::hash;\n\n// A ship is defined by its start and end coordinates\nstruct Ship {\n    start_x: u8,\n    start_y: u8,\n    end_x: u8,\n    end_y: u8\n}\n\n// Main circuit for board placement validation\nfn main(\n    ships: [Ship; 5],        // Private: Ship positions\n    salt: Field,             // Private: Random salt for commitment\n    board_commitment: pub Field  // Public: Commitment to board state\n) {\n    // Board size constants\n    let board_size = 10;     // 10x10 board\n    \n    // Ship sizes in order [carrier, battleship, cruiser, submarine, destroyer]\n    let ship_size_0 = 5;  // Carrier\n    let ship_size_1 = 4;  // Battleship\n    let ship_size_2 = 3;  // Cruiser\n    let ship_size_3 = 3;  // Submarine\n    let ship_size_4 = 2;  // Destroyer\n    \n    // Step 1: Validate each ship is within bounds and has correct size\n    for i in 0..5 {\n        let ship = ships[i];\n        \n        // Check ship is on the board\n        assert(ship.start_x < board_size);\n        assert(ship.start_y < board_size);\n        assert(ship.end_x < board_size);\n        assert(ship.end_y < board_size);\n        \n        // Check ship is either horizontal or vertical\n        let is_horizontal = ship.start_y == ship.end_y;\n        let is_vertical = ship.start_x == ship.end_x;\n        assert(is_horizontal | is_vertical);\n        \n        // Special case for single-cell ships (shouldn't happen in valid battleship)\n        if is_horizontal & is_vertical {\n            assert(ship.start_x == ship.end_x);\n            assert(ship.start_y == ship.end_y);\n        }\n        \n        // Normalize ship coordinates\n        let normalized_ship = normalize_ship(ship);\n        \n        // Calculate ship length\n        let length = if is_horizontal {\n            normalized_ship.end_x - normalized_ship.start_x + 1\n        } else {\n            normalized_ship.end_y - normalized_ship.start_y + 1\n        };\n        \n        // Verify correct ship size\n        if i == 0 {\n            assert(length == ship_size_0);\n        } else if i == 1 {\n            assert(length == ship_size_1);\n        } else if i == 2 {\n            assert(length == ship_size_2);\n        } else if i == 3 {\n            assert(length == ship_size_3);\n        } else {\n            assert(length == ship_size_4);\n        }\n    }\n    \n    // Step 2: Check no ships overlap\n    for i in 0..4 {\n        for j in (i+1)..5 {\n            assert(!ships_overlap(ships[i], ships[j]));\n        }\n    }\n    \n    // Step 3: Calculate and verify board commitment\n    let calculated_commitment = calculate_board_commitment(ships, salt);\n    // assert(calculated_commitment == board_commitment);\n    // Use this to see the actual values in error messages\nif (calculated_commitment != board_commitment) {\n    assert(false);\n}\n}\n\n// Normalize ship coordinates so start is always less than or equal to end\nfn normalize_ship(ship: Ship) -> Ship {\n    if ship.start_x == ship.end_x {\n        // Vertical ship\n        if ship.start_y <= ship.end_y {\n            ship\n        } else {\n            Ship {\n                start_x: ship.start_x,\n                start_y: ship.end_y,\n                end_x: ship.end_x,\n                end_y: ship.start_y\n            }\n        }\n    } else {\n        // Horizontal ship\n        if ship.start_x <= ship.end_x {\n            ship\n        } else {\n            Ship {\n                start_x: ship.end_x,\n                start_y: ship.start_y,\n                end_x: ship.start_x,\n                end_y: ship.end_y\n            }\n        }\n    }\n}\n\n// Check if two ships overlap\nfn ships_overlap(ship1: Ship, ship2: Ship) -> bool {\n    // Normalize ships so start coordinates are less than end\n    let s1 = normalize_ship(ship1);\n    let s2 = normalize_ship(ship2);\n    \n    let mut result = false;\n    \n    // Ship 1 horizontal\n    if s1.start_y == s1.end_y {\n        // Ship 2 horizontal\n        if s2.start_y == s2.end_y {\n            // Both horizontal - check if they're on the same row and overlap\n            if s1.start_y == s2.start_y {\n                // Check overlap on x-axis\n                if !(s1.end_x < s2.start_x | s1.start_x > s2.end_x) {\n                    result = true;\n                }\n            }\n        } else {\n            // Ship 1 horizontal, Ship 2 vertical\n            // Check if vertical ship crosses the horizontal ship's row\n            if s2.start_x >= s1.start_x {\n                if s2.start_x <= s1.end_x {\n                    if s1.start_y >= s2.start_y {\n                        if s1.start_y <= s2.end_y {\n                            result = true;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        // Ship 1 vertical\n        if s2.start_y == s2.end_y {\n            // Ship 1 vertical, Ship 2 horizontal\n            // Check if horizontal ship crosses the vertical ship's column\n            if s1.start_x >= s2.start_x {\n                if s1.start_x <= s2.end_x {\n                    if s2.start_y >= s1.start_y {\n                        if s2.start_y <= s1.end_y {\n                            result = true;\n                        }\n                    }\n                }\n            }\n        } else {\n            // Both vertical - check if they're on the same column and overlap\n            if s1.start_x == s2.start_x {\n                // Check overlap on y-axis\n                if !(s1.end_y < s2.start_y | s1.start_y > s2.end_y) {\n                    result = true;\n                }\n            }\n        }\n    }\n    \n    result\n}\n\n// Calculate the board commitment using Pedersen hash\nfn calculate_board_commitment(ships: [Ship; 5], salt: Field) -> Field {\n    // Flatten ship data for hashing\n    let mut data: [Field; 21] = [0; 21]; // 5 ships x 4 coordinates + 1 salt\n    \n    for i in 0..5 {\n        data[i*4] = ships[i].start_x as Field;\n        data[i*4 + 1] = ships[i].start_y as Field;\n        data[i*4 + 2] = ships[i].end_x as Field;\n        data[i*4 + 3] = ships[i].end_y as Field;\n    }\n    data[20] = salt;\n    \n    // Use the Pedersen hash from the standard library\n    hash::pedersen_hash(data)\n}\n\n// Test with valid ships\nfn test_valid_placement() {\n    // Create a valid board setup with non-overlapping ships\n    let ships = [\n        Ship { start_x: 0, start_y: 0, end_x: 4, end_y: 0 }, // Carrier - Length 5\n        Ship { start_x: 0, start_y: 2, end_x: 3, end_y: 2 }, // Battleship - Length 4\n        Ship { start_x: 5, start_y: 5, end_x: 7, end_y: 5 }, // Cruiser - Length 3\n        Ship { start_x: 9, start_y: 0, end_x: 9, end_y: 2 }, // Submarine - Length 3\n        Ship { start_x: 3, start_y: 7, end_x: 4, end_y: 7 }  // Destroyer - Length 2\n    ];\n    \n    let salt = 12345;\n    let commitment = calculate_board_commitment(ships, salt);\n    \n    // This should pass validation\n    main(ships, salt, commitment);\n}\n\n// This function will be run when the circuit is compiled \n// It serves as the primary test\nfn dummy_entrypoint() {\n    test_valid_placement();\n}","path":"/Users/lazerpay/Desktop/open-source/kripson/circuit/board_placement/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_integer_quotient","directive_invert"]}